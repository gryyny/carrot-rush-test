var gdjs;(function(s){const g=new s.Logger("Multiplayer");class ye{constructor($){this.maxSize=$,this.cache=new Set,this.keys=[]}has($){return this.cache.has($)}add($){if(this.cache.size>=this.maxSize){const A=this.keys.shift();A&&this.cache.delete(A)}this.cache.add($),this.keys.push($)}}s.makeMultiplayerMessageManager=()=>{const L=0,$=0,A=0,be=0,O=window.performance&&typeof window.performance.now=="function"?window.performance.now.bind(window.performance):Date.now,ve=200,Me=4,W=new ye(500);let y={},N={};const Ie=1;let Q=0,F=null,C=0;const Oe=1;let Z=0,k=null,j=0;const $e=1;let ee=0,P={},te={},D={1:0},E=[];const R=({originalMessageName:e,originalData:r,expectedMessageName:a,otherPeerIds:n,shouldCancelMessageIfTimesOut:t,maxNumberOfRetries:c,messageRetryTime:o})=>{!s.multiplayer.isLobbyGameRunning()||(y[a]||(y[a]={}),g.info(`Adding expected message ${a} from ${n.join(", ")}.`),n.forEach(i=>{y[a][i]={acknowledged:!1,lastMessageSentAt:O(),originalMessageName:e,originalData:r,shouldCancelMessageIfTimesOut:t,numberOfRetries:0,maxNumberOfRetries:c||Me,messageRetryTime:o||ve}}))},De=()=>{y={},N={}},ne=({sceneNetworkId:e,instanceNetworkId:r})=>(N[e]||(N[e]={}),N[e][r]||0),se=({sceneNetworkId:e,instanceNetworkId:r,clock:a})=>{N[e]||(N[e]={}),N[e][r]=a},w=(e,r,a)=>{if(!($>0&&Math.random()<$)){if(A>0&&Math.random()<A){setTimeout(()=>{s.evtTools.p2p.sendDataTo(e,r,JSON.stringify(a))},be);return}if(L>0){setTimeout(()=>{s.evtTools.p2p.sendDataTo(e,r,JSON.stringify(a))},L);return}s.evtTools.p2p.sendDataTo(e,r,JSON.stringify(a))}},Se=(e,r,a)=>{if(!e.length)return null;let n=null,t=1/0;for(let c=0;c<e.length;++c){if(e[c].networkId)continue;const o=e[c],i=Math.pow(o.getX()-r,2)+Math.pow(o.getY()-a,2);i<t&&(n=o,t=i)}return n},V=({runtimeScene:e,objectName:r,instanceNetworkId:a,instanceX:n,instanceY:t,shouldCreateIfNotFound:c})=>{const o=e.getInstancesOf(r);if(!o)return null;let i=o.find(l=>l.networkId===a)||null;if(i||(g.info(`instance ${r} ${a} not found with network ID, trying to find it with persistent UUID.`),i=o.find(l=>l.persistentUuid&&l.persistentUuid.substring(0,8)===a)||null,i&&(g.info(`instance ${r} ${a} found with persistent UUID. Assigning network ID.`),i.networkId=a)),!i&&n!==void 0&&t!==void 0){g.info(`instance ${r} ${a} not found with network ID, trying to find it with position ${n}/${t}.`);const l=Se(o,n,t);l&&(g.info(`Found closest instance for object ${r} ${a} with no network ID.`),i=l,i.networkId=a)}if(!i&&c){g.info(`Instance ${a} still not found, Creating instance ${r}.`);const l=e.createObject(r);if(!l)return null;l.networkId=a,i=l}return i},x="#changeInstanceOwner",ae=/#changeInstanceOwner#owner_(\d+)#object_(.+)#instance_(.+)/,Ne=({objectOwner:e,objectName:r,instanceNetworkId:a,newObjectOwner:n,instanceX:t,instanceY:c,sceneNetworkId:o})=>({messageName:`${x}#owner_${e}#object_${r}#instance_${a}`,messageData:{previousOwner:e,newOwner:n,instanceX:t,instanceY:c,sceneNetworkId:o}}),U="#instanceOwnerChanged",ke=/#instanceOwnerChanged#owner_(\d+)#object_(.+)#instance_(.+)/,re=e=>e.replace(x,U),Te=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(x)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){const c=s.evtTools.p2p.getEventData(t);let o;try{o=JSON.parse(c)}catch(l){g.error(`Error while parsing message ${t}: ${l.toString()}`);return}const i=s.evtTools.p2p.getEventSender(t);if(o){const l=ae.exec(t);if(!l)return;const d=l[2],u=l[3],p=o.previousOwner,f=o.newOwner,m=o.sceneNetworkId;if(m!==e.networkId){g.info(`Object ${d} is in scene ${m}, but we are on ${e.networkId}. Skipping.`);return}const b=V({runtimeScene:e,objectName:d,instanceNetworkId:u,instanceX:o.instanceX,instanceY:o.instanceY});if(!b){g.info(`Instance ${u} not found, it must have been destroyed.`);return}const M=b.getBehavior("MultiplayerObject");if(!M){g.warn(`Object ${d} does not have the MultiplayerObjectBehavior, cannot change ownership.`);return}const h=M.getPlayerObjectOwnership(),v=h===p||h===f;if(s.multiplayer.isPlayerHost()&&!v){g.warn(`Object ${d} with instance network ID ${u} does not have the expected owner. Wanted to change from ${p} to ${f}, but object has owner ${h}.`);return}g.info(`Changing ownership of object ${d} to ${f}.`),M.playerNumber=f;const I=re(t);if(g.info(`Sending acknowledgment of ownership change of object ${d} from ${p} to ${f} with instance network ID ${u} to ${i}.`),w(i,I,{}),s.multiplayer.isPlayerHost()){const G=s.evtTools.p2p.getAllPeers().filter(S=>S!==i);if(!G.length)return;R({originalMessageName:t,originalData:o,expectedMessageName:I,otherPeerIds:G,shouldCancelMessageIfTimesOut:!1});for(const S of G)g.info(`Relaying ownership change of object ${d} with instance network ID ${u} to ${S}.`),w(S,t,o)}}}})},oe="#updateInstance",Pe=/#updateInstance#owner_(\d+)#object_(.+)#instance_(.+)#scene_(.+)/,Re=({objectOwner:e,objectName:r,instanceNetworkId:a,objectNetworkSyncData:n,sceneNetworkId:t})=>({messageName:`${oe}#owner_${e}#object_${r}#instance_${a}#scene_${t}`,messageData:n}),Ae=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(oe)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!0)){const c=s.evtTools.p2p.getEventData(t);let o;try{o=JSON.parse(c)}catch(l){g.error(`Error while parsing message ${t}: ${l.toString()}`);return}const i=s.evtTools.p2p.getEventSender(t);if(o){const l=Pe.exec(t);if(!l)return;const d=parseInt(l[1],10);if(d===s.multiplayer.playerNumber)return;const u=l[2],p=l[3],f=l[4];if(f!==e.networkId){g.info(`Object ${u} is in scene ${f}, but we are on ${e.networkId}. Skipping.`);return}const m=o._clock,b=ne({sceneNetworkId:f,instanceNetworkId:p});if(m<=b)return;const M=V({runtimeScene:e,objectName:u,instanceNetworkId:p,shouldCreateIfNotFound:!0,instanceX:o.x,instanceY:o.y});if(!M){g.error("Instance could not be found or created.");return}const h=M.getBehavior("MultiplayerObject");if(!h){g.error(`Object ${u} does not have the MultiplayerObjectBehavior, cannot update it.`);return}if(h.getPlayerObjectOwnership()===s.multiplayer.playerNumber){g.info(`Object ${u} with instance network ID ${p} is owned by us ${s.multiplayer.playerNumber}, ignoring update message from ${d}.`);return}if(h.getPlayerObjectOwnership()!==d&&(g.info(`Object ${u} with instance network ID ${p} is owned by ${h.getPlayerObjectOwnership()} on our game, changing ownership to ${d} as part of the update event.`),h.playerNumber=d),M.updateFromObjectNetworkSyncData(o),se({sceneNetworkId:f,instanceNetworkId:p,clock:m}),s.multiplayer.isPlayerHost()){const v=s.evtTools.p2p.getAllPeers();for(const I of v)I!==i&&w(I,t,o)}}}})},_="#changeVariableOwner",ie=/#changeVariableOwner#owner_(\d+)#variable_(.+)/,Ee=({variableOwner:e,variableNetworkId:r,newVariableOwner:a})=>({messageName:`${_}#owner_${e}#variable_${r}`,messageData:{previousOwner:e,newOwner:a}}),J="#variableOwnerChanged",Ce=/#variableOwnerChanged#owner_(\d+)#variable_(.+)/,ce=e=>e.replace(_,J),je=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(_)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){const c=s.evtTools.p2p.getEventData(t);let o;try{o=JSON.parse(c)}catch(l){g.error(`Error while parsing message ${t}: ${l.toString()}`);return}const i=s.evtTools.p2p.getEventSender(t);if(o){const l=ie.exec(t);if(!l)return;const d=l[2],u=o.previousOwner,p=o.newOwner,{type:f,name:m,containerId:b}=s.multiplayerVariablesManager.getVariableTypeAndNameFromNetworkId(d);if(f==="scene"&&b!==e.networkId){g.info(`Variable ${m} is in scene ${b}, but we are on ${e.networkId}. Skipping.`);return}const M=b==="game"?e.getGame().getVariables():e.getVariables();if(!M.has(m)){g.error(`Variable with ID ${d} not found whilst syncing. This should not happen.`);return}const h=M.get(m),v=h.getPlayerOwnership(),I=v===u||v===p;if(s.multiplayer.isPlayerHost()&&!I){g.warn(`Variable with ID ${d} does not have the expected owner. Wanted to change from ${u} to ${p}, but variable has owner ${v}.`);return}g.info(`Changing ownership of variable ${m} to ${p}.`),h.setPlayerOwnership(p);const T=ce(t);if(g.info(`Sending acknowledgment of ownership change of variable with ID ${d} from ${u} to ${p} to ${i}.`),w(i,T,{}),s.multiplayer.isPlayerHost()){const S=s.evtTools.p2p.getAllPeers().filter(H=>H!==i);if(!S.length)return;R({originalMessageName:t,originalData:o,expectedMessageName:T,otherPeerIds:S,shouldCancelMessageIfTimesOut:!1});for(const H of S)g.info(`Relaying ownership change of variable with Id ${d} to ${H}.`),w(H,t,o)}}}})},xe=e=>e.startsWith(K)?Fe:e.startsWith(U)?ke:e.startsWith(J)?Ce:e.startsWith(X)?Be:null,_e=e=>e.startsWith(K)||e.startsWith(U)||e.startsWith(J)||e.startsWith(X),Ge=()=>{const e=s.evtTools.p2p.getEvents();Array.from(e.keys()).filter(_e).forEach(n=>{if(s.evtTools.p2p.onEvent(n,!1)){g.info(`Received acknowledgment for message ${n}.`);const t=s.evtTools.p2p.getEvent(n);let c;for(;c=t.getData();){const o=t.getSender(),i=xe(n);if(!i){g.error(`Invalid acknowledgment message ${n}.`),t.popData();return}const l=i.exec(n);if(!l){g.error(`Invalid acknowledgment message ${n}.`),t.popData();return}if(!y[n]){t.popData();return}if(!y[n][o]){t.popData();return}const d=c._clock;if(d!==void 0){const u=l[3],p=l[4],f=ne({sceneNetworkId:p,instanceNetworkId:u});if(d<=f)return;se({sceneNetworkId:p,instanceNetworkId:u,clock:d})}g.info(`Marking message ${n} as acknowledged from ${o}.`),y[n][o].acknowledged=!0,t.popData()}}})},He=e=>{Object.keys(y).forEach(a=>{const n=y[a],t=Object.keys(n).filter(c=>!n[c].acknowledged);if(!t.length)g.info(`All peers have acknowledged message ${a}.`),delete y[a];else for(const c of t){const{lastMessageSentAt:o,originalMessageName:i,originalData:l,numberOfRetries:d,maxNumberOfRetries:u,messageRetryTime:p}=n[c];if(O()-o>p){if(d>=u){if(g.info(`Giving up on message ${a} for ${c}.`),n[c].shouldCancelMessageIfTimesOut){if(i.startsWith(x)){const f=ae.exec(i);if(!f){delete y[a];return}const m=f[2],b=f[3],M=e.getInstancesOf(m);if(!M){delete y[a];return}let h=M.find(T=>T.networkId===b);if(!h){delete y[a];return}const v=h.getBehavior("MultiplayerObject");if(!v){g.warn(`Object ${m} does not have the MultiplayerObjectBehavior, cannot revert ownership.`),delete y[a];return}const I=l.previousOwner;if(I===void 0){delete y[a];return}v.playerNumber=I||0}if(i.startsWith(_)){const f=ie.exec(i);if(!f){delete y[a];return}const m=f[2],b=l.previousOwner,{type:M,name:h,containerId:v}=s.multiplayerVariablesManager.getVariableTypeAndNameFromNetworkId(m);if(M==="scene"&&v!==e.networkId){g.info(`Variable ${h} is in scene ${v}, but we are on ${e.networkId}. Skipping ownership revert.`),delete y[a];return}const I=v==="game"?e.getGame().getVariables():e.getVariables();if(!I.has(h)){g.error(`Variable with ID ${m} not found while reverting ownership. This should not happen.`),delete y[a];return}const T=I.get(h);if(b===void 0){delete y[a];return}T.setPlayerOwnership(b||0)}}delete y[a];continue}w(c,i,l),n[c].lastMessageSentAt=O(),n[c].numberOfRetries=d+1}}})},B="#destroyInstance",Le=/#destroyInstance#owner_(\d+)#object_(.+)#instance_(.+)#scene_(.+)/,We=({objectOwner:e,objectName:r,instanceNetworkId:a,sceneNetworkId:n})=>({messageName:`${B}#owner_${e}#object_${r}#instance_${a}#scene_${n}`,messageData:{}}),K="#instanceDestroyed",Fe=/#instanceDestroyed#owner_(\d+)#object_(.+)#instance_(.+)/,le=e=>e.replace(B,K),Ve=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(B)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){let c;const o=s.evtTools.p2p.getEventData(t);try{c=JSON.parse(o)}catch(l){g.error(`Error while parsing message ${t}: ${l.toString()}`);return}const i=s.evtTools.p2p.getEventSender(t);if(c&&i){g.info(`Received message ${t} with data ${o}.`);const l=Le.exec(t);if(!l||parseInt(l[1],10)===s.multiplayer.playerNumber)return;const u=l[2],p=l[3],f=l[4];if(f!==e.networkId){g.info(`Object ${u} is in scene ${f}, but we are on ${e.networkId}. Skipping.`);return}const m=V({runtimeScene:e,objectName:u,instanceNetworkId:p}),b=le(t);if(!m){g.info("Instance was not found in the scene, sending acknowledgment anyway."),w(i,b,{});return}if(g.info(`Destroying object ${u} with instance network ID ${p}.`),m.deleteFromScene(e),g.info(`Sending acknowledgment of destruction of object ${u} with instance network ID ${p} to ${i}.`),w(i,b,{}),s.multiplayer.isPlayerHost()){const h=s.evtTools.p2p.getAllPeers().filter(v=>v!==i);if(!h.length)return;R({originalMessageName:t,originalData:c,expectedMessageName:b,otherPeerIds:h,shouldCancelMessageIfTimesOut:!1});for(const v of h)w(v,t,c)}}}})},Y="#customMessage",Ue=/#customMessage#(.+)/,q=e=>`${Y}#${e}`,Je=({userMessageName:e,userMessageData:r})=>{const a=s.makeUuid();return{messageName:q(e),messageData:{data:r,uniqueId:a}}},X="#ackCustomMessage",Be=/#ackCustomMessage#(.+)/,ge=e=>e.replace(Y,X),Ke=(e,r)=>{const a=s.evtTools.p2p.getAllPeers(),{messageName:n,messageData:t}=Je({userMessageName:e,userMessageData:r}),c=ge(n);R({originalMessageName:n,originalData:t,expectedMessageName:c,otherPeerIds:a,shouldCancelMessageIfTimesOut:!1});for(const o of a)w(o,n,t);s.multiplayer.isPlayerHost()&&s.evtTools.p2p.getEvent(n).pushData(new s.evtTools.p2p.EventData(JSON.stringify(t),s.evtTools.p2p.getCurrentId()))},Ye=e=>{const r=q(e);if(s.evtTools.p2p.onEvent(r,!1)){const n=s.evtTools.p2p.getEventData(r);let t;try{t=JSON.parse(n)}catch(i){return g.error(`Error while parsing message ${r}: ${i.toString()}`),!1}const c=t.uniqueId,o=`${r}#${c}`;return W.has(o)?!1:(W.add(o),!0)}return!1},qe=e=>{const r=q(e),a=s.evtTools.p2p.getEventData(r);let n;try{n=JSON.parse(a)}catch(t){return g.error(`Error while parsing message ${e}: ${t.toString()}`),""}return n.data},Xe=()=>{const e=s.evtTools.p2p.getEvents();Array.from(e.keys()).filter(n=>n.startsWith(Y)).forEach(n=>{if(s.evtTools.p2p.onEvent(n,!1)){const t=s.evtTools.p2p.getEvent(n),c=t.getData();let o;try{o=JSON.parse(c)}catch(f){g.error(`Error while parsing message ${n}: ${f.toString()}`);return}const i=o.uniqueId,l=t.getSender();if(g.info(`Received custom message ${n} with data ${c}.`),!Ue.exec(n)){g.error(`Invalid custom message ${n}.`);return}const u=`${n}#${i}`;if(W.has(u)){g.info(`Message ${n} has already been processed, skipping.`);return}const p=ge(n);if(g.info(`Sending acknowledgment of custom message ${n} to ${l}.`),w(l,p,{}),s.multiplayer.isPlayerHost()){const f=s.evtTools.p2p.getAllPeers();if(!f.length)return;R({originalMessageName:n,originalData:o,expectedMessageName:p,otherPeerIds:f,shouldCancelMessageIfTimesOut:!1});for(const m of f)w(m,n,o)}}})},de="#updateScene",ue=({sceneNetworkSyncData:e})=>({messageName:`${de}`,messageData:e}),ze=e=>e.var?F?JSON.stringify(e.var)!==JSON.stringify(F.var):!0:!1,Qe=()=>O()-Q<1e3/Ie,Ze=e=>{const r=e.getNetworkSyncData({playerNumber:s.multiplayer.getCurrentPlayerNumber()});if(!r)return;const a=ze(r),n=!Qe()||a||C>0;if(a&&(C=3),!n)return;const t=s.evtTools.p2p.getAllPeers(),{messageName:c,messageData:o}=ue({sceneNetworkSyncData:r});for(const i of t)w(i,c,o);Q=O(),F=r,C=Math.max(C-1,0)},et=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(de)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){const c=s.evtTools.p2p.getEvent(t);let o;for(;o=c.getData();){let i;try{i=JSON.parse(o)}catch(d){g.error(`Error while parsing message ${t}: ${d.toString()}`),c.popData();return}const l=s.evtTools.p2p.getEventSender(t);if(i&&l){const d=i.id;if(d!==e.networkId){g.info(`Received update of scene ${d}, but we are on ${e.networkId}. Skipping.`),c.popData();return}if(e.updateFromNetworkSyncData(i),s.multiplayer.isPlayerHost()){const u=s.evtTools.p2p.getAllPeers();for(const p of u)p!==l&&w(p,t,i)}}c.popData()}}})},pe="#updateGame",fe=({gameNetworkSyncData:e})=>({messageName:`${pe}`,messageData:e}),tt=e=>{const r=e.var,a=e.ss;if(!r&&!a)return!1;if(!k||!k.var||!k.ss||r&&JSON.stringify(r)!==JSON.stringify(k.var))return!0;if(a){if(a.length!==k.ss.length)return!0;for(let n=0;n<a.length;++n){const t=a[n],c=k.ss[n];if(t.name!==c.name||t.networkId!==c.networkId)return!0}}return!1},nt=()=>O()-Z<1e3/Oe,st=e=>{const r=e.getGame().getNetworkSyncData({playerNumber:s.multiplayer.getCurrentPlayerNumber()});if(!r)return;const a=tt(r),n=!nt()||a||j>0;if(a&&(j=3),!n)return;const t=s.evtTools.p2p.getAllPeers(),{messageName:c,messageData:o}=fe({gameNetworkSyncData:r});for(const i of t)w(i,c,o);Z=O(),k=r,j=Math.max(j-1,0)},at=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(pe)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){const c=s.evtTools.p2p.getEvent(t);let o;for(;o=c.getData();){let i;try{i=JSON.parse(o)}catch(d){g.error(`Error while parsing message ${t}: ${d.toString()}`),c.popData();return}const l=c.getSender();if(i&&l&&(e.getGame().updateFromNetworkSyncData(i),s.multiplayer.isPlayerHost())){const d=s.evtTools.p2p.getAllPeers();for(const u of d)u!==l&&w(u,t,i)}c.popData()}}})},z="#heartbeat",rt=/#heartbeat#(.+)/,ot=()=>{const e={1:0};for(const r in P)e[r]=me(parseInt(r,10));return{messageName:`${z}#${s.multiplayer.getCurrentPlayerNumber()}`,messageData:{now:O(),playersPings:e}}},it=({heartbeatSentAt:e})=>({messageName:`${z}#${s.multiplayer.getCurrentPlayerNumber()}`,messageData:{sentAt:e}}),ct=()=>O()-ee<1e3/$e,lt=()=>{if(!s.multiplayer.isPlayerHost()||!!ct())return;const r=s.evtTools.p2p.getAllPeers(),{messageName:a,messageData:n}=ot();for(const t of r)w(t,a,n);ee=O()},gt=()=>{const e=s.evtTools.p2p.getEvents();Array.from(e.keys()).filter(n=>n.startsWith(z)).forEach(n=>{if(s.evtTools.p2p.onEvent(n,!1)){const t=s.evtTools.p2p.getEventData(n);let c;try{c=JSON.parse(t)}catch(i){g.error(`Error while parsing message ${n}: ${i.toString()}`);return}const o=s.evtTools.p2p.getEventSender(n);if(c&&o){const i=rt.exec(n);if(!i)return;const l=parseInt(i[1],10);if(te[o]=l,!s.multiplayer.isPlayerHost()){D=c.playersPings;const{messageName:h,messageData:v}=it({heartbeatSentAt:c.now});w(o,h,v);return}const d=O(),u=c.sentAt,p=Math.round(d-u),m=(P[l]||{}).lastRoundTripTimes||[];m.push(p),m.length>5&&m.shift(),P[l]={lastRoundTripTimes:m};let b=0;for(const h of m)b+=h;const M=Math.round(b/m.length/2);D[l]=M}}})},me=e=>e<1?0:D[e]||0,dt=e=>{if(g.info(`Marking player ${e} as disconnected.`),E.push(e),e===1){g.info("Host has disconnected, ending the game."),P={},D={},s.multiplayer.handleLobbyGameEnded();return}delete P[e],delete D[e]},ut=e=>{if(!s.multiplayer.isLobbyGameRunning())return;const r=[],a=s.evtTools.p2p.getDisconnectedPeer();if(a){g.info(`Disconnected peer: ${a}`);const n=te[a];if(!n)return;g.info(`Player ${n} has disconnected.`),r.push(n)}for(const n of r){if(s.multiplayer.isPlayerHost()){const t=e.getAdhocListOfAllInstances();for(const c of t){g.info("Found instances "+c.getName());const o=c.getBehavior("MultiplayerObject");if(o&&o.getPlayerObjectOwnership()===n){const i=o.getActionOnPlayerDisconnect();i==="DestroyObject"?c.deleteFromScene(e):i==="GiveOwnershipToHost"&&o.removeObjectOwnership()}}}dt(n)}},pt=()=>{E=[]},ft=()=>E.length>0,mt=e=>E.includes(e),ht=()=>E,yt=()=>Object.keys(D).length,wt=e=>D[e]!==void 0,he="#endGame",bt=()=>({messageName:he,messageData:{}});return{sendDataTo:w,addExpectedMessageAcknowledgement:R,clearExpectedMessageAcknowledgements:De,handleAcknowledgeMessagesReceived:Ge,resendClearOrCancelAcknowledgedMessages:He,createChangeInstanceOwnerMessage:Ne,createInstanceOwnerChangedMessageNameFromChangeInstanceOwnerMessage:re,handleChangeInstanceOwnerMessagesReceived:Te,createUpdateInstanceMessage:Re,handleUpdateInstanceMessagesReceived:Ae,createDestroyInstanceMessage:We,createInstanceDestroyedMessageNameFromDestroyInstanceMessage:le,handleDestroyInstanceMessagesReceived:Ve,createChangeVariableOwnerMessage:Ee,createVariableOwnerChangedMessageNameFromChangeVariableOwnerMessage:ce,handleChangeVariableOwnerMessagesReceived:je,sendMessage:Ke,hasMessageBeenReceived:Ye,getMessageData:qe,handleCustomMessagesReceived:Xe,createUpdateSceneMessage:ue,handleUpdateSceneMessagesToSend:Ze,handleUpdateSceneMessagesReceived:et,createUpdateGameMessage:fe,handleUpdateGameMessagesToSend:st,handleUpdateGameMessagesReceived:at,handleHeartbeatsToSend:lt,handleHeartbeatsReceived:gt,getPlayerPing:me,updatePlayersPingsForTests:e=>{D=e},handleDisconnectedPeers:ut,clearDisconnectedPeers:pt,hasAnyPlayerLeft:ft,hasPlayerLeft:mt,getDisconnectedPlayers:ht,getNumberOfConnectedPlayers:yt,isPlayerConnected:wt,sendEndGameMessage:()=>{if(!s.multiplayer.isPlayerHost())return;const e=s.evtTools.p2p.getAllPeers(),{messageName:r,messageData:a}=bt();for(const n of e)w(n,r,a)},handleEndGameMessages:()=>{if(s.multiplayer.isPlayerHost())return;const e=s.evtTools.p2p.getEvents();Array.from(e.keys()).filter(n=>n===he).forEach(n=>{g.info(`Received endgame message ${n}.`),s.evtTools.p2p.onEvent(n,!1)&&(P={},D={},s.multiplayer.handleLobbyGameEnded())})}}},s.multiplayerMessageManager=s.makeMultiplayerMessageManager()})(gdjs||(gdjs={}));
//# sourceMappingURL=messageManager.js.map
