var gdjs;(function(s){const y=new s.Logger("Multiplayer"),d=new s.Logger("Multiplayer - Debug");s.Logger.getDefaultConsoleLoggerOutput().discardGroup("Multiplayer - Debug");class we{constructor(D){this.maxSize=D,this.cache=new Set,this.keys=[]}has(D){return this.cache.has(D)}add(D){if(this.cache.size>=this.maxSize){const E=this.keys.shift();E&&this.cache.delete(E)}this.cache.add(D),this.keys.push(D)}}s.makeMultiplayerMessageManager=()=>{const W=0,D=0,E=0,ve=0,$=window.performance&&typeof window.performance.now=="function"?window.performance.now.bind(window.performance):Date.now,Me=200,Ie=4,F=new we(500);let w={},k={};const Oe=1;let ee=0,V=null,j=0;const $e=1;let te=0,T=null,x=0;const De=1;let ne=0,R={},se={},S={1:0},C=[];const A=({originalMessageName:e,originalData:r,expectedMessageName:a,otherPeerIds:n,shouldCancelMessageIfTimesOut:t,maxNumberOfRetries:c,messageRetryTime:o})=>{!s.multiplayer.isLobbyGameRunning()||(w[a]||(w[a]={}),d.info(`Adding expected message ${a} from ${n.join(", ")}.`),n.forEach(i=>{w[a][i]={acknowledged:!1,lastMessageSentAt:$(),originalMessageName:e,originalData:r,shouldCancelMessageIfTimesOut:t,numberOfRetries:0,maxNumberOfRetries:c||Ie,messageRetryTime:o||Me}}))},Se=()=>{w={},k={}},ae=({sceneNetworkId:e,instanceNetworkId:r})=>(k[e]||(k[e]={}),k[e][r]||0),re=({sceneNetworkId:e,instanceNetworkId:r,clock:a})=>{k[e]||(k[e]={}),k[e][r]=a},b=(e,r,a)=>{if(!(D>0&&Math.random()<D)){if(E>0&&Math.random()<E){setTimeout(()=>{s.evtTools.p2p.sendDataTo(e,r,JSON.stringify(a))},ve);return}if(W>0){setTimeout(()=>{s.evtTools.p2p.sendDataTo(e,r,JSON.stringify(a))},W);return}s.evtTools.p2p.sendDataTo(e,r,JSON.stringify(a))}},Ne=(e,r,a)=>{if(!e.length)return null;let n=null,t=1/0;for(let c=0;c<e.length;++c){if(e[c].networkId)continue;const o=e[c],i=Math.pow(o.getX()-r,2)+Math.pow(o.getY()-a,2);i<t&&(n=o,t=i)}return n},U=({runtimeScene:e,objectName:r,instanceNetworkId:a,instanceX:n,instanceY:t,shouldCreateIfNotFound:c})=>{const o=e.getInstancesOf(r);if(!o)return null;let i=o.find(l=>l.networkId===a)||null;if(i||(d.info(`instance ${r} ${a} not found with network ID, trying to find it with persistent UUID.`),i=o.find(l=>l.persistentUuid&&l.persistentUuid.substring(0,8)===a)||null,i&&(d.info(`instance ${r} ${a} found with persistent UUID. Assigning network ID.`),i.networkId=a)),!i&&n!==void 0&&t!==void 0){d.info(`instance ${r} ${a} not found with network ID, trying to find it with position ${n}/${t}.`);const l=Ne(o,n,t);l&&(d.info(`Found closest instance for object ${r} ${a} with no network ID.`),i=l,i.networkId=a)}if(!i&&c){d.info(`Instance ${a} still not found, Creating instance ${r}.`);const l=e.createObject(r);if(!l)return null;l.networkId=a,i=l}return i},_="#changeInstanceOwner",oe=/#changeInstanceOwner#owner_(\d+)#object_(.+)#instance_(.+)/,ke=({objectOwner:e,objectName:r,instanceNetworkId:a,newObjectOwner:n,instanceX:t,instanceY:c,sceneNetworkId:o})=>({messageName:`${_}#owner_${e}#object_${r}#instance_${a}`,messageData:{previousOwner:e,newOwner:n,instanceX:t,instanceY:c,sceneNetworkId:o}}),J="#instanceOwnerChanged",Te=/#instanceOwnerChanged#owner_(\d+)#object_(.+)#instance_(.+)/,ie=e=>e.replace(_,J),Pe=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(_)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){const c=s.evtTools.p2p.getEventData(t);let o;try{o=JSON.parse(c)}catch(l){y.error(`Error while parsing message ${t}: ${l.toString()}`);return}const i=s.evtTools.p2p.getEventSender(t);if(o){const l=oe.exec(t);if(!l)return;const g=l[2],u=l[3],p=o.previousOwner,f=o.newOwner,m=o.sceneNetworkId;if(m!==e.networkId){d.info(`Object ${g} is in scene ${m}, but we are on ${e.networkId}. Skipping.`);return}const v=U({runtimeScene:e,objectName:g,instanceNetworkId:u,instanceX:o.instanceX,instanceY:o.instanceY});if(!v){d.info(`Instance ${u} not found, it must have been destroyed.`);return}const I=v.getBehavior("MultiplayerObject");if(!I){d.info(`Object ${g} does not have the MultiplayerObjectBehavior, cannot change ownership.`);return}const h=I.getPlayerObjectOwnership(),M=h===p||h===f;if(s.multiplayer.isPlayerHost()&&!M){d.info(`Object ${g} with instance network ID ${u} does not have the expected owner. Wanted to change from ${p} to ${f}, but object has owner ${h}.`);return}d.info(`Changing ownership of object ${g} to ${f}.`),I.playerNumber=f;const O=ie(t);if(d.info(`Sending acknowledgment of ownership change of object ${g} from ${p} to ${f} with instance network ID ${u} to ${i}.`),b(i,O,{}),s.multiplayer.isPlayerHost()){const H=s.evtTools.p2p.getAllPeers().filter(N=>N!==i);if(!H.length)return;A({originalMessageName:t,originalData:o,expectedMessageName:O,otherPeerIds:H,shouldCancelMessageIfTimesOut:!1});for(const N of H)d.info(`Relaying ownership change of object ${g} with instance network ID ${u} to ${N}.`),b(N,t,o)}}}})},ce="#updateInstance",Re=/#updateInstance#owner_(\d+)#object_(.+)#instance_(.+)#scene_(.+)/,Ae=({objectOwner:e,objectName:r,instanceNetworkId:a,objectNetworkSyncData:n,sceneNetworkId:t})=>({messageName:`${ce}#owner_${e}#object_${r}#instance_${a}#scene_${t}`,messageData:n}),Ee=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(ce)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!0)){const c=s.evtTools.p2p.getEventData(t);let o;try{o=JSON.parse(c)}catch(l){y.error(`Error while parsing message ${t}: ${l.toString()}`);return}const i=s.evtTools.p2p.getEventSender(t);if(o){const l=Re.exec(t);if(!l)return;const g=parseInt(l[1],10);if(g===s.multiplayer.playerNumber)return;const u=l[2],p=l[3],f=l[4];if(f!==e.networkId){d.info(`Object ${u} is in scene ${f}, but we are on ${e.networkId}. Skipping.`);return}const m=o._clock,v=ae({sceneNetworkId:f,instanceNetworkId:p});if(m<=v)return;const I=U({runtimeScene:e,objectName:u,instanceNetworkId:p,shouldCreateIfNotFound:!0,instanceX:o.x,instanceY:o.y});if(!I){y.error("Instance could not be found or created.");return}const h=I.getBehavior("MultiplayerObject");if(!h){y.error(`Object ${u} does not have the MultiplayerObjectBehavior, cannot update it.`);return}if(h.getPlayerObjectOwnership()===s.multiplayer.playerNumber){d.info(`Object ${u} with instance network ID ${p} is owned by us ${s.multiplayer.playerNumber}, ignoring update message from ${g}.`);return}if(h.getPlayerObjectOwnership()!==g&&(d.info(`Object ${u} with instance network ID ${p} is owned by ${h.getPlayerObjectOwnership()} on our game, changing ownership to ${g} as part of the update event.`),h.playerNumber=g),I.updateFromNetworkSyncData(o),re({sceneNetworkId:f,instanceNetworkId:p,clock:m}),s.multiplayer.isPlayerHost()){const M=s.evtTools.p2p.getAllPeers();for(const O of M)O!==i&&b(O,t,o)}}}})},G="#changeVariableOwner",le=/#changeVariableOwner#owner_(\d+)#variable_(.+)/,Ce=({variableOwner:e,variableNetworkId:r,newVariableOwner:a})=>({messageName:`${G}#owner_${e}#variable_${r}`,messageData:{previousOwner:e,newOwner:a}}),B="#variableOwnerChanged",je=/#variableOwnerChanged#owner_(\d+)#variable_(.+)/,ge=e=>e.replace(G,B),xe=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(G)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){const c=s.evtTools.p2p.getEventData(t);let o;try{o=JSON.parse(c)}catch(l){y.error(`Error while parsing message ${t}: ${l.toString()}`);return}const i=s.evtTools.p2p.getEventSender(t);if(o){const l=le.exec(t);if(!l)return;const g=l[2],u=o.previousOwner,p=o.newOwner,{type:f,name:m,containerId:v}=s.multiplayerVariablesManager.getVariableTypeAndNameFromNetworkId(g);if(f==="scene"&&v!==e.networkId){d.info(`Variable ${m} is in scene ${v}, but we are on ${e.networkId}. Skipping.`);return}const I=v==="game"?e.getGame().getVariables():e.getVariables();if(!I.has(m)){y.error(`Variable with ID ${g} not found whilst syncing. This should not happen.`);return}const h=I.get(m),M=h.getPlayerOwnership(),O=M===u||M===p;if(s.multiplayer.isPlayerHost()&&!O){d.info(`Variable with ID ${g} does not have the expected owner. Wanted to change from ${u} to ${p}, but variable has owner ${M}.`);return}d.info(`Changing ownership of variable ${m} to ${p}.`),h.setPlayerOwnership(p);const P=ge(t);if(d.info(`Sending acknowledgment of ownership change of variable with ID ${g} from ${u} to ${p} to ${i}.`),b(i,P,{}),s.multiplayer.isPlayerHost()){const N=s.evtTools.p2p.getAllPeers().filter(L=>L!==i);if(!N.length)return;A({originalMessageName:t,originalData:o,expectedMessageName:P,otherPeerIds:N,shouldCancelMessageIfTimesOut:!1});for(const L of N)d.info(`Relaying ownership change of variable with Id ${g} to ${L}.`),b(L,t,o)}}}})},_e=e=>e.startsWith(Y)?Ve:e.startsWith(J)?Te:e.startsWith(B)?je:e.startsWith(z)?Ke:null,Ge=e=>e.startsWith(Y)||e.startsWith(J)||e.startsWith(B)||e.startsWith(z),He=()=>{const e=s.evtTools.p2p.getEvents();Array.from(e.keys()).filter(Ge).forEach(n=>{if(s.evtTools.p2p.onEvent(n,!1)){d.info(`Received acknowledgment for message ${n}.`);const t=s.evtTools.p2p.getEvent(n);let c;for(;c=t.getData();){const o=t.getSender(),i=_e(n);if(!i){y.error(`Invalid acknowledgment message ${n}.`),t.popData();return}const l=i.exec(n);if(!l){y.error(`Invalid acknowledgment message ${n}.`),t.popData();return}if(!w[n]){t.popData();return}if(!w[n][o]){t.popData();return}const g=c._clock;if(g!==void 0){const u=l[3],p=l[4],f=ae({sceneNetworkId:p,instanceNetworkId:u});if(g<=f)return;re({sceneNetworkId:p,instanceNetworkId:u,clock:g})}d.info(`Marking message ${n} as acknowledged from ${o}.`),w[n][o].acknowledged=!0,t.popData()}}})},Le=e=>{Object.keys(w).forEach(a=>{const n=w[a],t=Object.keys(n).filter(c=>!n[c].acknowledged);if(!t.length)d.info(`All peers have acknowledged message ${a}.`),delete w[a];else for(const c of t){const{lastMessageSentAt:o,originalMessageName:i,originalData:l,numberOfRetries:g,maxNumberOfRetries:u,messageRetryTime:p}=n[c];if($()-o>p){if(g>=u){if(d.info(`Giving up on message ${a} for ${c}.`),n[c].shouldCancelMessageIfTimesOut){if(i.startsWith(_)){const f=oe.exec(i);if(!f){delete w[a];return}const m=f[2],v=f[3],I=e.getInstancesOf(m);if(!I){delete w[a];return}let h=I.find(P=>P.networkId===v);if(!h){delete w[a];return}const M=h.getBehavior("MultiplayerObject");if(!M){y.error(`Object ${m} does not have the MultiplayerObjectBehavior, cannot revert ownership.`),delete w[a];return}const O=l.previousOwner;if(O===void 0){delete w[a];return}M.playerNumber=O||0}if(i.startsWith(G)){const f=le.exec(i);if(!f){delete w[a];return}const m=f[2],v=l.previousOwner,{type:I,name:h,containerId:M}=s.multiplayerVariablesManager.getVariableTypeAndNameFromNetworkId(m);if(I==="scene"&&M!==e.networkId){d.info(`Variable ${h} is in scene ${M}, but we are on ${e.networkId}. Skipping ownership revert.`),delete w[a];return}const O=M==="game"?e.getGame().getVariables():e.getVariables();if(!O.has(h)){y.error(`Variable with ID ${m} not found while reverting ownership. This should not happen.`),delete w[a];return}const P=O.get(h);if(v===void 0){delete w[a];return}P.setPlayerOwnership(v||0)}}delete w[a];continue}b(c,i,l),n[c].lastMessageSentAt=$(),n[c].numberOfRetries=g+1}}})},K="#destroyInstance",We=/#destroyInstance#owner_(\d+)#object_(.+)#instance_(.+)#scene_(.+)/,Fe=({objectOwner:e,objectName:r,instanceNetworkId:a,sceneNetworkId:n})=>({messageName:`${K}#owner_${e}#object_${r}#instance_${a}#scene_${n}`,messageData:{}}),Y="#instanceDestroyed",Ve=/#instanceDestroyed#owner_(\d+)#object_(.+)#instance_(.+)/,de=e=>e.replace(K,Y),Ue=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(K)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){let c;const o=s.evtTools.p2p.getEventData(t);try{c=JSON.parse(o)}catch(l){y.error(`Error while parsing message ${t}: ${l.toString()}`);return}const i=s.evtTools.p2p.getEventSender(t);if(c&&i){d.info(`Received message ${t} with data ${o}.`);const l=We.exec(t);if(!l||parseInt(l[1],10)===s.multiplayer.playerNumber)return;const u=l[2],p=l[3],f=l[4];if(f!==e.networkId){d.info(`Object ${u} is in scene ${f}, but we are on ${e.networkId}. Skipping.`);return}const m=U({runtimeScene:e,objectName:u,instanceNetworkId:p}),v=de(t);if(!m){d.info("Instance was not found in the scene, sending acknowledgment anyway."),b(i,v,{});return}if(d.info(`Destroying object ${u} with instance network ID ${p}.`),m.deleteFromScene(e),d.info(`Sending acknowledgment of destruction of object ${u} with instance network ID ${p} to ${i}.`),b(i,v,{}),s.multiplayer.isPlayerHost()){const h=s.evtTools.p2p.getAllPeers().filter(M=>M!==i);if(!h.length)return;A({originalMessageName:t,originalData:c,expectedMessageName:v,otherPeerIds:h,shouldCancelMessageIfTimesOut:!1});for(const M of h)b(M,t,c)}}}})},q="#customMessage",Je=/#customMessage#(.+)/,X=e=>`${q}#${e}`,Be=({userMessageName:e,userMessageData:r})=>{const a=s.makeUuid();return{messageName:X(e),messageData:{data:r,uniqueId:a}}},z="#ackCustomMessage",Ke=/#ackCustomMessage#(.+)/,ue=e=>e.replace(q,z),Ye=(e,r)=>{const a=s.evtTools.p2p.getAllPeers(),{messageName:n,messageData:t}=Be({userMessageName:e,userMessageData:r}),c=ue(n);A({originalMessageName:n,originalData:t,expectedMessageName:c,otherPeerIds:a,shouldCancelMessageIfTimesOut:!1});for(const o of a)b(o,n,t);s.multiplayer.isPlayerHost()&&s.evtTools.p2p.getEvent(n).pushData(new s.evtTools.p2p.EventData(JSON.stringify(t),s.evtTools.p2p.getCurrentId()))},qe=e=>{const r=X(e);if(s.evtTools.p2p.onEvent(r,!1)){const n=s.evtTools.p2p.getEventData(r);let t;try{t=JSON.parse(n)}catch(i){return y.error(`Error while parsing message ${r}: ${i.toString()}`),!1}const c=t.uniqueId,o=`${r}#${c}`;return F.has(o)?!1:(F.add(o),!0)}return!1},Xe=e=>{const r=X(e),a=s.evtTools.p2p.getEventData(r);let n;try{n=JSON.parse(a)}catch(t){return y.error(`Error while parsing message ${e}: ${t.toString()}`),""}return n.data},ze=()=>{const e=s.evtTools.p2p.getEvents();Array.from(e.keys()).filter(n=>n.startsWith(q)).forEach(n=>{if(s.evtTools.p2p.onEvent(n,!1)){const t=s.evtTools.p2p.getEvent(n),c=t.getData();let o;try{o=JSON.parse(c)}catch(f){y.error(`Error while parsing message ${n}: ${f.toString()}`);return}const i=o.uniqueId,l=t.getSender();if(d.info(`Received custom message ${n} with data ${c}.`),!Je.exec(n)){y.error(`Invalid custom message ${n}.`);return}const u=`${n}#${i}`;if(F.has(u)){d.info(`Message ${n} has already been processed, skipping.`);return}const p=ue(n);if(d.info(`Sending acknowledgment of custom message ${n} to ${l}.`),b(l,p,{}),s.multiplayer.isPlayerHost()){const f=s.evtTools.p2p.getAllPeers();if(!f.length)return;A({originalMessageName:n,originalData:o,expectedMessageName:p,otherPeerIds:f,shouldCancelMessageIfTimesOut:!1});for(const m of f)b(m,n,o)}}})},pe="#updateScene",fe=({sceneNetworkSyncData:e})=>({messageName:`${pe}`,messageData:e}),Qe=e=>e.var?V?JSON.stringify(e.var)!==JSON.stringify(V.var):!0:!1,Ze=()=>$()-ee<1e3/Oe,et=e=>{const r=e.getNetworkSyncData({playerNumber:s.multiplayer.getCurrentPlayerNumber()});if(!r)return;const a=Qe(r),n=!Ze()||a||j>0;if(a&&(j=3),!n)return;const t=s.evtTools.p2p.getAllPeers(),{messageName:c,messageData:o}=fe({sceneNetworkSyncData:r});for(const i of t)b(i,c,o);ee=$(),V=r,j=Math.max(j-1,0)},tt=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(pe)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){const c=s.evtTools.p2p.getEvent(t);let o;for(;o=c.getData();){let i;try{i=JSON.parse(o)}catch(g){y.error(`Error while parsing message ${t}: ${g.toString()}`),c.popData();return}const l=s.evtTools.p2p.getEventSender(t);if(i&&l){const g=i.id;if(g!==e.networkId){d.info(`Received update of scene ${g}, but we are on ${e.networkId}. Skipping.`),c.popData();return}if(e.updateFromNetworkSyncData(i),s.multiplayer.isPlayerHost()){const u=s.evtTools.p2p.getAllPeers();for(const p of u)p!==l&&b(p,t,i)}}c.popData()}}})},me="#updateGame",he=({gameNetworkSyncData:e})=>({messageName:`${me}`,messageData:e}),nt=e=>{const r=e.var,a=e.ss;if(!r&&!a)return!1;if(!T||!T.var||!T.ss||r&&JSON.stringify(r)!==JSON.stringify(T.var))return!0;if(a){if(a.length!==T.ss.length)return!0;for(let n=0;n<a.length;++n){const t=a[n],c=T.ss[n];if(t.name!==c.name||t.networkId!==c.networkId)return!0}}return!1},st=()=>$()-te<1e3/$e,at=e=>{const r=e.getGame().getNetworkSyncData({playerNumber:s.multiplayer.getCurrentPlayerNumber()});if(!r)return;const a=nt(r),n=!st()||a||x>0;if(a&&(x=3),!n)return;const t=s.evtTools.p2p.getAllPeers(),{messageName:c,messageData:o}=he({gameNetworkSyncData:r});for(const i of t)b(i,c,o);te=$(),T=r,x=Math.max(x-1,0)},rt=e=>{const r=s.evtTools.p2p.getEvents();Array.from(r.keys()).filter(t=>t.startsWith(me)).forEach(t=>{if(s.evtTools.p2p.onEvent(t,!1)){const c=s.evtTools.p2p.getEvent(t);let o;for(;o=c.getData();){let i;try{i=JSON.parse(o)}catch(g){y.error(`Error while parsing message ${t}: ${g.toString()}`),c.popData();return}const l=c.getSender();if(i&&l&&(e.getGame().updateFromNetworkSyncData(i),s.multiplayer.isPlayerHost())){const g=s.evtTools.p2p.getAllPeers();for(const u of g)u!==l&&b(u,t,i)}c.popData()}}})},Q="#heartbeat",ot=/#heartbeat#(.+)/,it=()=>{const e={1:0};for(const r in R)e[r]=Z(parseInt(r,10));return{messageName:`${Q}#${s.multiplayer.getCurrentPlayerNumber()}`,messageData:{now:$(),playersPings:e}}},ct=({heartbeatSentAt:e})=>({messageName:`${Q}#${s.multiplayer.getCurrentPlayerNumber()}`,messageData:{sentAt:e}}),lt=()=>$()-ne<1e3/De,gt=()=>{if(!s.multiplayer.isPlayerHost()||!!lt())return;const r=s.evtTools.p2p.getAllPeers(),{messageName:a,messageData:n}=it();for(const t of r)b(t,a,n);ne=$()},dt=()=>{const e=s.evtTools.p2p.getEvents();Array.from(e.keys()).filter(n=>n.startsWith(Q)).forEach(n=>{if(s.evtTools.p2p.onEvent(n,!1)){const t=s.evtTools.p2p.getEventData(n);let c;try{c=JSON.parse(t)}catch(i){y.error(`Error while parsing message ${n}: ${i.toString()}`);return}const o=s.evtTools.p2p.getEventSender(n);if(c&&o){const i=ot.exec(n);if(!i)return;const l=parseInt(i[1],10);if(se[o]=l,!s.multiplayer.isPlayerHost()){S=c.playersPings;const{messageName:h,messageData:M}=ct({heartbeatSentAt:c.now});b(o,h,M);return}const g=$(),u=c.sentAt,p=Math.round(g-u),m=(R[l]||{}).lastRoundTripTimes||[];m.push(p),m.length>5&&m.shift(),R[l]={lastRoundTripTimes:m};let v=0;for(const h of m)v+=h;const I=Math.round(v/m.length/2);S[l]=I}}})},Z=e=>e<1?0:S[e]||0,ut=()=>{const e=s.multiplayer.getCurrentPlayerNumber();return Z(e)},pt=e=>{if(y.info(`Marking player ${e} as disconnected.`),C.push(e),e===1){y.info("Host has disconnected, ending the game."),R={},S={},s.multiplayer.handleLobbyGameEnded();return}delete R[e],delete S[e]},ft=e=>{if(!s.multiplayer.isLobbyGameRunning())return;const r=[],a=s.evtTools.p2p.getDisconnectedPeer();if(a){const n=se[a];if(!n)return;y.info(`Player ${n} has disconnected.`),r.push(n)}for(const n of r){if(s.multiplayer.isPlayerHost()){const t=e.getAdhocListOfAllInstances();for(const c of t){const o=c.getBehavior("MultiplayerObject");if(o&&o.getPlayerObjectOwnership()===n){const i=o.getActionOnPlayerDisconnect();i==="DestroyObject"?c.deleteFromScene(e):i==="GiveOwnershipToHost"&&o.removeObjectOwnership()}}}pt(n)}},mt=()=>{C=[]},ht=()=>C.length>0,yt=e=>C.includes(e),wt=()=>C,bt=()=>Object.keys(S).length,vt=e=>S[e]!==void 0,ye="#endGame",Mt=()=>({messageName:ye,messageData:{}});return{sendDataTo:b,addExpectedMessageAcknowledgement:A,clearExpectedMessageAcknowledgements:Se,handleAcknowledgeMessagesReceived:He,resendClearOrCancelAcknowledgedMessages:Le,createChangeInstanceOwnerMessage:ke,createInstanceOwnerChangedMessageNameFromChangeInstanceOwnerMessage:ie,handleChangeInstanceOwnerMessagesReceived:Pe,createUpdateInstanceMessage:Ae,handleUpdateInstanceMessagesReceived:Ee,createDestroyInstanceMessage:Fe,createInstanceDestroyedMessageNameFromDestroyInstanceMessage:de,handleDestroyInstanceMessagesReceived:Ue,createChangeVariableOwnerMessage:Ce,createVariableOwnerChangedMessageNameFromChangeVariableOwnerMessage:ge,handleChangeVariableOwnerMessagesReceived:xe,sendMessage:Ye,hasMessageBeenReceived:qe,getMessageData:Xe,handleCustomMessagesReceived:ze,createUpdateSceneMessage:fe,handleUpdateSceneMessagesToSend:et,handleUpdateSceneMessagesReceived:tt,createUpdateGameMessage:he,handleUpdateGameMessagesToSend:at,handleUpdateGameMessagesReceived:rt,handleHeartbeatsToSend:gt,handleHeartbeatsReceived:dt,getPlayerPing:Z,getCurrentPlayerPing:ut,updatePlayersPingsForTests:e=>{S=e},handleDisconnectedPeers:ft,clearDisconnectedPeers:mt,hasAnyPlayerLeft:ht,hasPlayerLeft:yt,getDisconnectedPlayers:wt,getNumberOfConnectedPlayers:bt,isPlayerConnected:vt,sendEndGameMessage:()=>{if(!s.multiplayer.isPlayerHost())return;const e=s.evtTools.p2p.getAllPeers(),{messageName:r,messageData:a}=Mt();for(const n of e)b(n,r,a)},handleEndGameMessages:()=>{if(s.multiplayer.isPlayerHost())return;const e=s.evtTools.p2p.getEvents();Array.from(e.keys()).filter(n=>n===ye).forEach(n=>{y.info(`Received endgame message ${n}.`),s.evtTools.p2p.onEvent(n,!1)&&(R={},S={},s.multiplayer.handleLobbyGameEnded())})}}},s.multiplayerMessageManager=s.makeMultiplayerMessageManager()})(gdjs||(gdjs={}));
//# sourceMappingURL=messageManager.js.map
